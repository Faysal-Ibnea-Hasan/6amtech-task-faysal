## Credentials

### Admin

**email:** 6amtech@admin.com

**password:** 6amtech6

### Test Users

**email:** devfaysalhasan@gmail.com

**password:** 123456789

* Note: you can register new user from **/register** route


## Setup Instructions

Follow these steps to get the application up and running on your local machine.

### Prerequisites

Ensure you have the following installed:

  * **PHP:** Version 8.2 or higher
  * **Composer:** Latest stable version
  * **Node.js:** Version 16 or higher
  * **NPM / Yarn:** Latest stable version
  * **Database:** MySQL (recommended)

### Installation Steps

1.  **Clone the Repository:**

    ```bash
    https://github.com/Faysal-Ibnea-Hasan/6amtech-task-faysal.git
    cd 6amtech-task-faysal
    ```

2.  **Install PHP Dependencies:**

    ```bash
    composer install
    ```

3.  **Install Node.js Dependencies:**

    ```bash
    npm install 
    ```

4.  **Create `.env` File:**

    ```bash
    cp .env.example .env
    ```

5.  **Generate Application Key:**

    ```bash
    php artisan key:generate
    ```


6.  **Run Database Migrations and Seeders:**
    This will set up your database tables and populate them with initial data, including a large dataset for testing performance optimizations.

    ```bash
    php artisan migrate:fresh --seed
    ```

    *Note: The seeding process may take a few minutes due to the large amount of dummy data being generated for inventory and transactions.*

7.  **Build Frontend Assets:**

    ```bash
    npm run dev 
    # or
    npm run build 
    ```

8.  **Start the Local Development Server:**

    ```bash
    php artisan serve
    ```

You can now access the application in your browser at `http://127.0.0.1:8000`.

-----

## Environment Configuration Details

After running `cp .env.example .env`, you need to configure the following variables in your `.env` file.

### Application Configuration

  * **`APP_NAME`**: Your Project Name
  * **`APP_ENV`**: `local` (for development), `production` (for deployment)
  * **`APP_KEY`**: (Generated by `php artisan key:generate`)
  * **`APP_DEBUG`**: `true` (for development), `false` (for production)
  * **`APP_URL`**: `http://localhost`

### Database Configuration

  * **`DB_CONNECTION`**: `mysql`
  * **`DB_HOST`**: `127.0.0.1` (or your database host)
  * **`DB_PORT`**: `3306` (MySQL)
  * **`DB_DATABASE`**: Database name
  * **`DB_USERNAME`**: Database user 
  * **`DB_PASSWORD`**: Database password

### JWT Authentication Configuration

  * **`JWT_SECRET`**: (Required for JWT token generation and validation. Generate using `php artisan jwt:secret`)

-----

## Deployment Steps

These steps outline a typical deployment process for a Laravel application to a production server. This assumes a Linux-based server (e.g., Ubuntu) with Nginx/Apache, PHP-FPM, and Composer installed.

### 1\. Server Preparation

  * **Install Dependencies:** Ensure PHP (with necessary extensions), Composer, Node.js, NPM, Git, Nginx/Apache, and your chosen database (MySQL/PostgreSQL) are installed and configured.
  * **Create Database:** Create a dedicated database and user for your application on the production server.

### 2\. Code Deployment

  * **Clone Repository (on server):**

    ```bash
    git clone https://github.com/Faysal-Ibnea-Hasan/6amtech-task-faysal.git /var/www/6amtech-task-faysal
    cd /var/www/6amtech-task-faysal
    ```

  * **Install PHP Dependencies:**

    ```bash
    composer install --optimize-autoloader --no-dev
    ```

    *The `--no-dev` flag ensures development-only dependencies are not installed, and `--optimize-autoloader` speeds up class loading.*

  * **Install Node.js Dependencies & Build Assets:**

    ```bash
    npm install --production # or yarn install --production
    npm run build # Build production-ready frontend assets
    ```

### 3\. Environment Configuration

  * **Create `.env`:** Copy `.env.example` to `.env`.
  * **Configure `.env` for Production:**
      * Set `APP_ENV=production`
      * Set `APP_DEBUG=false`
      * Set `APP_URL` to your production domain (e.g., `https://your-domain.com`)
      * Update `DB_DATABASE`, `DB_USERNAME`, `DB_PASSWORD` with production database credentials.
      * Generate `APP_KEY` and `JWT_SECRET` if not already present from your development setup.
        ```bash
        php artisan key:generate
        php artisan jwt:secret
        ```
      * Configure `CACHE_DRIVER` and `QUEUE_CONNECTION` to `redis` or `memcached` / `database` respectively for better performance.

### 4\. Storage Linking & Permissions

  * **Create Storage Link:**
    ```bash
    php artisan storage:link
    ```
  * **Set Permissions:** Ensure the web server user has write permissions to the `storage` and `bootstrap/cache` directories.
    ```bash
    sudo chown -R www-data:www-data /var/www/6amtech-task-faysal
    sudo chmod -R 775 /var/www/6amtech-task-faysal/storage
    sudo chmod -R 775 /var/www/6amtech-task-faysal/bootstrap/cache
    ```
    *(Adjust `www-data` to your web server user, e.g., `nginx` or `apache`.)*

### 5\. Database Setup

  * **Run Migrations:**

    ```bash
    php artisan migrate --force
    ```

    *The `--force` flag is required in production to confirm you want to run migrations.*

  * **Run Seeders:**

    ```bash
    php artisan db:seed
    ```

### 6\. Web Server Configuration (Nginx Example)

Create a new Nginx server block configuration for your domain:

```nginx
server {
    listen 80;
    listen [::]:80;
    server_name your-domain.com www.your-domain.com;
    root /var/www/6amtech-task-faysal/public;

    add_header X-Frame-Options "SAMEORIGIN";
    add_header X-XSS-Protection "1; mode=block";
    add_header X-Content-Type-Options "nosniff";

    index index.php index.html index.htm;

    charset utf-8;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        fastcgi_pass unix:/var/run/php/php8.2-fpm.sock; # Adjust PHP version
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
        include fastcgi_params;
    }

    location ~ /\.(?!well-known).* {
        deny all;
    }
}
```

  * **Enable Site:**
    ```bash
    sudo ln -s /etc/nginx/sites-available/your-domain.com /etc/nginx/sites-enabled/
    ```
  * **Test Nginx Configuration:**
    ```bash
    sudo nginx -t
    ```
  * **Restart Nginx:**
    ```bash
    sudo systemctl restart nginx
    ```

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Understood. Here's your **entire `README.md` content** fully preserved, only **Markdown-formatted** for proper rendering ‚Äî no changes to your actual content or data.

---

````markdown
# Task 2

I can certainly help you generate a `README.md` file for your Task Management API based on the code you provided\!

Here's a comprehensive `README.md` structure that incorporates proper validation, error handling, and overall API usage, similar to the previous example, but ready to be pasted directly into a `README.md` file.

# Task Management API

This API provides endpoints for managing tasks, allowing authenticated users to create, retrieve, update, and delete their tasks. It includes robust validation and consistent error handling for a smooth developer experience.

---

## üöÄ Getting Started

To use this API, ensure you have a Laravel environment set up and the necessary dependencies installed.

### Prerequisites

* PHP >= 8.1  
* Composer  
* Laravel Framework  
* A database (MySQL, PostgreSQL, etc.)

### Installation

1. **Clone the repository:**

    ```bash
    git clone https://github.com/Faysal-Ibnea-Hasan/6amtech-task-faysal.git # Replace with your actual repository URL
    cd 6amtech-task-faysal
    ```

2. **Install Composer dependencies:**

    ```bash
    composer install
    ```

3. **Set up your `.env` file:**

    Copy `.env.example` to `.env` and configure your database connection and other environment variables.

    ```bash
    cp .env.example .env
    php artisan key:generate
    ```

4. **Run database migrations:**

    ```bash
    php artisan migrate
    ```

5. **(Optional) Seed the database:**

    If you have seeders for users or tasks:

    ```bash
    php artisan db:seed
    ```

6. **Start the development server:**

    ```bash
    php artisan serve
    ```

---

## üîê Authentication

This API uses **JWT (JSON Web Tokens)** for authentication. You'll need to obtain a token to access most endpoints.

**Endpoint:** `POST /api/auth/login` (or your configured login endpoint, e.g., `/api/login`)

**Request Body Example:**

```json
{
    "email": "devfaysalhasan@gmail.com",
    "password": "12345678"
}
````

**Successful Response Example:**

```json
{
    "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vMTI3LjAuMC4xOjgwMDAvYXBpL2F1dGgvbG9naW4iLCJpYXQi
OjE3NTI3OTE3NDIsImV4cCI6MTc1Mjc5NTM0MiwibmJmIjoxNzUyNzkxNzQyLCJqdGkiOiJHejRBVzA1TGZNVndJTjc0Iiwic3ViIjoiMiIsInBydiI6IjI
zYmQ1Yzg5NDlmNjAwYWRiMzllNzAxYzQwMDg3MmRiN2E1OTc2ZjciLCJyb2xlIjoidXNlciJ9.zO7MVeNNeEehFEH8t7xpDze77Dz-bsXqwhVp9jZed8E",
    "token_type": "bearer",
    "expires_in": 3600
}
```

Include the obtained `token` in the `Authorization` header of all subsequent requests:

```
Authorization: Bearer <your_jwt_token>
```

---

## üìù API Endpoints

All task-related endpoints are prefixed with `/api/task`.

### 1. Get All Tasks (`GET /api/task`)

Retrieves all tasks belonging to the authenticated user.

* **Authentication:** Required
* **Response:**

#### Success (200 OK):

```json
{
    "success": true,
    "message": "Successfully fetched task records.",
    "data": [
      {
        "id": 2,
        "user_id": 2,
        "assigned_by": null,
        "title": "First Task",
        "description": "This is First task",
        "status": null,
        "expire_date": "2025-10-12",
        "assignee": {
          "id": 2,
          "name": "Faysal Ibnea Hasan",
          "email": "devfaysalhasan@gmail.com",
          "email_verified_at": null,
          "role": "user",
          "is_active": 1,
          "created_at": "2025-07-15T14:53:29.000000Z",
          "updated_at": "2025-07-15T14:53:29.000000Z"
        },
        "assigner": null
      }
    ]
}
```

#### No Content (200 OK):

```json
{
    "success": true,
    "message": "No content.",
    "data": []
}
```

#### Error (404 Not Found):

```json
{
    "success": false,
    "message": "User not found.",
    "errors": []
}
```

---

### 2. Create a New Task (`POST /api/task`)

Creates a new task for the authenticated user.

* **Authentication:** Required
* **Request Body:**

  * `title` (string, required)
  * `description` (string, nullable)
  * `status` (string, nullable)
  * `expire_date` (date, nullable)

#### Example Request:

```json
{
  "title": "First Task",
  "description": "This is First task",
  "status": "in_progress",
  "expire_date": "12-10-2025"
}
```

#### Success (201 Created):

```json
{
   "success": true,
   "message": "Successfully created task.",
   "data": {
    "id": 2,
    "user_id": 2,
    "assigned_by": null,
    "title": "First Task",
    "description": "This is First task",
    "status": "in_progress",
    "expire_date": "2025-10-12"
  }
}
```

#### Error (422 Unprocessable Entity):

```json
{
    "success": false,
    "errors": {
        "title": [
            "The title field is required."
        ],
        "expire_date": [
            "The expire date must be a date after or equal to today."
        ]
    }
}
```

---

### 3. Get a Specific Task (`GET /api/task/{id}`)

Retrieves a single task by its ID.

* **Authentication:** Required

#### Success:

```json
{
  "success": true,
  "message": "Successfully fetched task records.",
  "data": {
    "id": 2,
    "user_id": 2,
    "assigned_by": null,
    "title": "First Task Update",
    "description": "This is First task update",
    "status": "in_progress",
    "expire_date": "2025-07-16",
    "assignee": {
      "id": 2,
      "name": "Faysal Ibnea Hasan",
      "email": "devfaysalhasan@gmail.com",
      "email_verified_at": null,
      "role": "user",
      "is_active": 1,
      "created_at": "2025-07-15T14:53:29.000000Z",
      "updated_at": "2025-07-15T14:53:29.000000Z"
    },
    "assigner": null
  }
}
```

#### Error (404 Not Found):

```json
{
  "success": false,
  "message": "Task not found.",
  "errors": []
}
```

#### Error (403 Forbidden):

```json
{
  "success": false,
  "message": "You are not authorized to access this task.",
  "errors": []
}
```

---

### 4. Update an Existing Task (`PUT /api/task/{id}`)

* **Authentication:** Required

#### Request Body:

```json
{
  "title": "First Task Update",
  "description": "This is First task update",
  "status": "completed"
}
```

#### Success:

```json
{
  "success": true,
  "message": "Successfully updated task.",
  "data": {
    "id": 2,
    "user_id": 2,
    "assigned_by": null,
    "title": "First Task Update",
    "description": "This is First task update",
    "status": "completed",
    "expire_date": "16-07-2025"
  }
}
```

#### Errors:

* **404 Not Found**
* **403 Forbidden**
* **422 Validation Error**
* **500 Internal Server Error**

```json
{
  "success": false,
  "message": "Failed to update task.",
  "errors": []
}
```

---

### 5. Delete a Task (`DELETE /api/task/{id}`)

* **Authentication:** Required

#### Success:

```json
{
  "success": true,
  "message": "Successfully deleted task.",
  "data": []
}
```

#### Errors:

* **404 Not Found**
* **403 Forbidden**
* **500 Internal Server Error**

```json
{
  "success": false,
  "message": "Failed to delete task.",
  "errors": []
}
```

---

## ‚úÖ Validation and Error Handling

Validation is done via Laravel Form Requests.

### Example Validation Error:

```json
{
  "success": false,
  "errors": {
    "field_name": ["Error message"]
  }
}
```

### Common Rules:

* `title`: required, string, max:255
* `description`: nullable
* `status`: Rule::in(TaskStatus::values())
* `expire_date`: after\_or\_equal\:today

---

## üõ†Ô∏è Code Structure Overview

* `Controllers\Api\Task\TaskController.php`
* `Requests\Task\StoreRequest.php`
* `Requests\Task\UpdateRequest.php`
* `Resources\TaskResource.php`
* `Models\Task.php`
* `Traits\CustomApiResponse.php`
* `Enums\TaskStatus.php`


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Task 3

## Database Optimization

For the Inventory Management System, particular attention has been paid to database query optimization, especially when dealing with potentially large datasets for `Products` and `Transactions`. This ensures the application remains performant and scalable.

### 1. Eager Loading (N+1 Problem Resolution)

**Problem:** A common performance anti-pattern is the "N+1 problem." This occurs when querying a list of parent records (the "1" query) and then, for each parent record, executing a separate query to fetch its associated child records (the "N" queries). For example, fetching 5,000 products and then 5,000 separate queries to get each product's category.

**Solution:** **Eager loading** was implemented using Laravel Eloquent's `with()` method. Instead of N+1 queries, eager loading fetches all parent records in one query and all related child records in a *single separate query*. This reduces the total query count to just 2, regardless of the number of records.

* **Example (Before Optimization):**
You can hit the route to postman or browser: http://127.0.0.1:8000/api/inventory/before 
    ```php
    $products = Product::all();
    foreach ($products as $product) {
        echo $product->category->name;
    }
    ```
{
  "message": "Product list before optimizing",
  "execution_time(seconds)": 3.0497,
  "products": 5000
}
    
*Observed in Debugbar: 1 (products) + N (categories) queries*


* **Example (After Optimization):**
You can hit the route to postman or browser: http://127.0.0.1:8000/api/inventory/after 
    ```php
    $products = Product::with('category')->get();
    foreach ($products as $product) {
        echo $product->category->name;
    }
    ```
{
  "message": "Optimized product list after optimizing",
  "execution_time(seconds)": 0.3059,
  "products": 5000
}
    
*Observed in Debugbar: 2 queries (1 for products, 1 for all relevant categories)*

This optimization drastically improves response times for listing operations involving relationships.

### 2. Database Indexing

**Purpose:** Database indexes are special lookup tables that the database search engine can use to speed up data retrieval. They are particularly effective on columns that are frequently used in `WHERE` clauses, `JOIN` conditions, or `ORDER BY` clauses.

**Implementation:**
* **Foreign Keys:** All foreign key columns (`category_id` on `products`, `user_id` and `product_id` on `transactions`) were implicitly indexed by Laravel's `foreignId()` method in the migrations. This is crucial for efficient joins and relationship lookups.
* **Unique Columns:** Columns defined as `unique()` (e.g., `products.name`, `categories.name`) also automatically receive an index, speeding up lookups and ensuring data integrity.
* **Considerations:** While beneficial, excessive indexing can slow down write (INSERT/UPDATE/DELETE) operations, as indexes also need to be updated. A balance is maintained by indexing only the most critical lookup fields.


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
